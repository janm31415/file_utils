/*
   Do this:
      #define FILE_UTILS_IMPLEMENTATION
   before you include this file in *one* C++ file to create the implementation.
   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define FILE_UTILS_IMPLEMENTATION
   #include "file_utils/file_utils.h"
 */


#pragma once

#include <string>
#include <vector>

#ifndef FUDEF
#ifdef FILE_UTILS_STATIC
#define FUDEF static
#else
#define FUDEF extern
#endif
#endif

namespace fu
  {
  FUDEF std::wstring convert_string_to_wstring(const std::string& str);
  FUDEF std::string convert_wstring_to_string(const std::wstring& str);
  FUDEF bool valid_utf8_file(const std::wstring& filename);
  FUDEF bool valid_utf8_file(const std::string& filename);
  FUDEF bool is_directory(const std::string& directory);
  FUDEF bool file_exists(const std::string& filename);
  FUDEF std::vector<std::string> get_files_from_directory(const std::string& d, bool include_subfolders);
  FUDEF std::vector<std::string> get_subdirectories_from_directory(const std::string& d, bool include_subfolders);
  FUDEF std::vector<std::string> get_list_from_directory(const std::string& d, bool include_subfolders);

  FUDEF std::string get_executable_path();
  FUDEF std::string get_cwd();
  /*
  Everything is assumed to be in utf8 encoding
  */
  FUDEF std::string get_extension(const std::string& filename);
  FUDEF std::string remove_extension(const std::string& filename);
  FUDEF std::string get_folder(const std::string& path);
  FUDEF std::string get_filename(const std::string& path);
  FUDEF std::string getenv(const std::string& name);
  FUDEF void putenv(const std::string& name, const std::string& value);

  FUDEF void csv_read(std::vector<std::vector<std::string>>& data, FILE* stream, const char* separator = ",");
  FUDEF bool csv_read(std::vector<std::vector<std::string>>& data, const char* filename, const char* separator = ",");

  FUDEF void csv_write(const std::vector<std::vector<std::string>>& data, FILE* stream, const char* separator = ",");
  FUDEF bool csv_write(const std::vector<std::vector<std::string>>& data, const char* filename, const char* separator = ",");

  FUDEF long long file_size(const std::string& filename);

  } // namespace fu

#ifdef FILE_UTILS_IMPLEMENTATION

// Copyright 2006 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include <iterator>
#include <stdexcept>

namespace fu {

  namespace utf8
    {
    // The typedefs for 8-bit, 16-bit and 32-bit unsigned integers
    // You may need to change them to match your system.
    // These typedefs have the same names as ones from cstdint, or boost/cstdint
    typedef unsigned char   uint8_t;
    typedef unsigned short  uint16_t;
    typedef unsigned int    uint32_t;

    // Helper code - not intended to be directly called by the library users. May be changed at any time
    namespace internal
      {
      // Unicode constants
      // Leading (high) surrogates: 0xd800 - 0xdbff
      // Trailing (low) surrogates: 0xdc00 - 0xdfff
      const uint16_t LEAD_SURROGATE_MIN = 0xd800u;
      const uint16_t LEAD_SURROGATE_MAX = 0xdbffu;
      const uint16_t TRAIL_SURROGATE_MIN = 0xdc00u;
      const uint16_t TRAIL_SURROGATE_MAX = 0xdfffu;
      const uint16_t LEAD_OFFSET = LEAD_SURROGATE_MIN - (0x10000 >> 10);
      const uint32_t SURROGATE_OFFSET = 0x10000u - (LEAD_SURROGATE_MIN << 10) - TRAIL_SURROGATE_MIN;

      // Maximum valid value for a Unicode code point
      const uint32_t CODE_POINT_MAX = 0x0010ffffu;

      template<typename octet_type>
      inline uint8_t mask8(octet_type oc)
        {
        return static_cast<uint8_t>(0xff & oc);
        }
      template<typename u16_type>
      inline uint16_t mask16(u16_type oc)
        {
        return static_cast<uint16_t>(0xffff & oc);
        }
      template<typename octet_type>
      inline bool is_trail(octet_type oc)
        {
        return ((utf8::internal::mask8(oc) >> 6) == 0x2);
        }

      template <typename u16>
      inline bool is_lead_surrogate(u16 cp)
        {
        return (cp >= LEAD_SURROGATE_MIN && cp <= LEAD_SURROGATE_MAX);
        }

      template <typename u16>
      inline bool is_trail_surrogate(u16 cp)
        {
        return (cp >= TRAIL_SURROGATE_MIN && cp <= TRAIL_SURROGATE_MAX);
        }

      template <typename u16>
      inline bool is_surrogate(u16 cp)
        {
        return (cp >= LEAD_SURROGATE_MIN && cp <= TRAIL_SURROGATE_MAX);
        }

      template <typename u32>
      inline bool is_code_point_valid(u32 cp)
        {
        return (cp <= CODE_POINT_MAX && !utf8::internal::is_surrogate(cp));
        }

      template <typename octet_iterator>
      inline typename std::iterator_traits<octet_iterator>::difference_type
        sequence_length(octet_iterator lead_it)
        {
        uint8_t lead = utf8::internal::mask8(*lead_it);
        if (lead < 0x80)
          return 1;
        else if ((lead >> 5) == 0x6)
          return 2;
        else if ((lead >> 4) == 0xe)
          return 3;
        else if ((lead >> 3) == 0x1e)
          return 4;
        else
          return 0;
        }

      template <typename octet_difference_type>
      inline bool is_overlong_sequence(uint32_t cp, octet_difference_type length)
        {
        if (cp < 0x80) {
          if (length != 1)
            return true;
          }
        else if (cp < 0x800) {
          if (length != 2)
            return true;
          }
        else if (cp < 0x10000) {
          if (length != 3)
            return true;
          }

        return false;
        }

      enum utf_error { UTF8_OK, NOT_ENOUGH_ROOM, INVALID_LEAD, INCOMPLETE_SEQUENCE, OVERLONG_SEQUENCE, INVALID_CODE_POINT };

      /// Helper for get_sequence_x
      template <typename octet_iterator>
      utf_error increase_safely(octet_iterator& it, octet_iterator end)
        {
        if (++it == end)
          return NOT_ENOUGH_ROOM;

        if (!utf8::internal::is_trail(*it))
          return INCOMPLETE_SEQUENCE;

        return UTF8_OK;
        }

#define UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(IT, END) {utf_error ret = increase_safely(IT, END); if (ret != UTF8_OK) return ret;}    

      /// get_sequence_x functions decode utf-8 sequences of the length x
      template <typename octet_iterator>
      utf_error get_sequence_1(octet_iterator& it, octet_iterator end, uint32_t& code_point)
        {
        if (it == end)
          return NOT_ENOUGH_ROOM;

        code_point = utf8::internal::mask8(*it);

        return UTF8_OK;
        }

      template <typename octet_iterator>
      utf_error get_sequence_2(octet_iterator& it, octet_iterator end, uint32_t& code_point)
        {
        if (it == end)
          return NOT_ENOUGH_ROOM;

        code_point = utf8::internal::mask8(*it);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

          code_point = ((code_point << 6) & 0x7ff) + ((*it) & 0x3f);

        return UTF8_OK;
        }

      template <typename octet_iterator>
      utf_error get_sequence_3(octet_iterator& it, octet_iterator end, uint32_t& code_point)
        {
        if (it == end)
          return NOT_ENOUGH_ROOM;

        code_point = utf8::internal::mask8(*it);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

          code_point = ((code_point << 12) & 0xffff) + ((utf8::internal::mask8(*it) << 6) & 0xfff);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

          code_point += (*it) & 0x3f;

        return UTF8_OK;
        }

      template <typename octet_iterator>
      utf_error get_sequence_4(octet_iterator& it, octet_iterator end, uint32_t& code_point)
        {
        if (it == end)
          return NOT_ENOUGH_ROOM;

        code_point = utf8::internal::mask8(*it);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

          code_point = ((code_point << 18) & 0x1fffff) + ((utf8::internal::mask8(*it) << 12) & 0x3ffff);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

          code_point += (utf8::internal::mask8(*it) << 6) & 0xfff;

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

          code_point += (*it) & 0x3f;

        return UTF8_OK;
        }

#undef UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR

      template <typename octet_iterator>
      utf_error validate_next(octet_iterator& it, octet_iterator end, uint32_t& code_point)
        {
        // Save the original value of it so we can go back in case of failure
        // Of course, it does not make much sense with i.e. stream iterators
        octet_iterator original_it = it;

        uint32_t cp = 0;
        // Determine the sequence length based on the lead octet
        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;
        const octet_difference_type length = utf8::internal::sequence_length(it);

        // Get trail octets and calculate the code point
        utf_error err = UTF8_OK;
        switch (length) {
          case 0:
            return INVALID_LEAD;
          case 1:
            err = utf8::internal::get_sequence_1(it, end, cp);
            break;
          case 2:
            err = utf8::internal::get_sequence_2(it, end, cp);
            break;
          case 3:
            err = utf8::internal::get_sequence_3(it, end, cp);
            break;
          case 4:
            err = utf8::internal::get_sequence_4(it, end, cp);
            break;
          }

        if (err == UTF8_OK) {
          // Decoding succeeded. Now, security checks...
          if (utf8::internal::is_code_point_valid(cp)) {
            if (!utf8::internal::is_overlong_sequence(cp, length)) {
              // Passed! Return here.
              code_point = cp;
              ++it;
              return UTF8_OK;
              }
            else
              err = OVERLONG_SEQUENCE;
            }
          else
            err = INVALID_CODE_POINT;
          }

        // Failure branch - restore the original value of the iterator
        it = original_it;
        return err;
        }

      template <typename octet_iterator>
      inline utf_error validate_next(octet_iterator& it, octet_iterator end) {
        uint32_t ignored;
        return utf8::internal::validate_next(it, end, ignored);
        }

      } // namespace internal

          /// The library API - functions intended to be called by the users

          // Byte order mark
    const uint8_t bom[] = { 0xef, 0xbb, 0xbf };

    template <typename octet_iterator>
    octet_iterator find_invalid(octet_iterator start, octet_iterator end)
      {
      octet_iterator result = start;
      while (result != end) {
        utf8::internal::utf_error err_code = utf8::internal::validate_next(result, end);
        if (err_code != internal::UTF8_OK)
          return result;
        }
      return result;
      }

    template <typename octet_iterator>
    inline bool is_valid(octet_iterator start, octet_iterator end)
      {
      return (utf8::find_invalid(start, end) == end);
      }

    template <typename octet_iterator>
    inline bool starts_with_bom(octet_iterator it, octet_iterator end)
      {
      return (
        ((it != end) && (utf8::internal::mask8(*it++)) == bom[0]) &&
        ((it != end) && (utf8::internal::mask8(*it++)) == bom[1]) &&
        ((it != end) && (utf8::internal::mask8(*it)) == bom[2])
        );
      }

    //Deprecated in release 2.3 
    template <typename octet_iterator>
    inline bool is_bom(octet_iterator it)
      {
      return (
        (utf8::internal::mask8(*it++)) == bom[0] &&
        (utf8::internal::mask8(*it++)) == bom[1] &&
        (utf8::internal::mask8(*it)) == bom[2]
        );
      }

    // Base for the exceptions that may be thrown from the library
    class exception : public ::std::exception {
      };

    // Exceptions that may be thrown from the library functions.
    class invalid_code_point : public exception {
      uint32_t cp;
    public:
      invalid_code_point(uint32_t cp) : cp(cp) {}
      virtual const char* what() const throw() { return "Invalid code point"; }
      uint32_t code_point() const { return cp; }
      };

    class invalid_utf8 : public exception {
      uint8_t u8;
    public:
      invalid_utf8(uint8_t u) : u8(u) {}
      virtual const char* what() const throw() { return "Invalid UTF-8"; }
      uint8_t utf8_octet() const { return u8; }
      };

    class invalid_utf16 : public exception {
      uint16_t u16;
    public:
      invalid_utf16(uint16_t u) : u16(u) {}
      virtual const char* what() const throw() { return "Invalid UTF-16"; }
      uint16_t utf16_word() const { return u16; }
      };

    class not_enough_room : public exception {
    public:
      virtual const char* what() const throw() { return "Not enough space"; }
      };

    /// The library API - functions intended to be called by the users

    template <typename octet_iterator>
    octet_iterator append(uint32_t cp, octet_iterator result)
      {
      if (!utf8::internal::is_code_point_valid(cp))
        throw invalid_code_point(cp);

      if (cp < 0x80)                        // one octet
        *(result++) = static_cast<uint8_t>(cp);
      else if (cp < 0x800) {                // two octets
        *(result++) = static_cast<uint8_t>((cp >> 6) | 0xc0);
        *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
        }
      else if (cp < 0x10000) {              // three octets
        *(result++) = static_cast<uint8_t>((cp >> 12) | 0xe0);
        *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
        *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
        }
      else {                                // four octets
        *(result++) = static_cast<uint8_t>((cp >> 18) | 0xf0);
        *(result++) = static_cast<uint8_t>(((cp >> 12) & 0x3f) | 0x80);
        *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
        *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
        }
      return result;
      }

    template <typename octet_iterator, typename output_iterator>
    output_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out, uint32_t replacement)
      {
      while (start != end) {
        octet_iterator sequence_start = start;
        internal::utf_error err_code = utf8::internal::validate_next(start, end);
        switch (err_code) {
          case internal::UTF8_OK:
            for (octet_iterator it = sequence_start; it != start; ++it)
              *out++ = *it;
            break;
          case internal::NOT_ENOUGH_ROOM:
            throw not_enough_room();
          case internal::INVALID_LEAD:
            out = utf8::append(replacement, out);
            ++start;
            break;
          case internal::INCOMPLETE_SEQUENCE:
          case internal::OVERLONG_SEQUENCE:
          case internal::INVALID_CODE_POINT:
            out = utf8::append(replacement, out);
            ++start;
            // just one replacement mark for the sequence
            while (start != end && utf8::internal::is_trail(*start))
              ++start;
            break;
          }
        }
      return out;
      }

    template <typename octet_iterator, typename output_iterator>
    inline output_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out)
      {
      static const uint32_t replacement_marker = utf8::internal::mask16(0xfffd);
      return utf8::replace_invalid(start, end, out, replacement_marker);
      }

    template <typename octet_iterator>
    uint32_t next(octet_iterator& it, octet_iterator end)
      {
      uint32_t cp = 0;
      internal::utf_error err_code = utf8::internal::validate_next(it, end, cp);
      switch (err_code) {
        case internal::UTF8_OK:
          break;
        case internal::NOT_ENOUGH_ROOM:
          throw not_enough_room();
        case internal::INVALID_LEAD:
        case internal::INCOMPLETE_SEQUENCE:
        case internal::OVERLONG_SEQUENCE:
          throw invalid_utf8(*it);
        case internal::INVALID_CODE_POINT:
          throw invalid_code_point(cp);
        }
      return cp;
      }

    template <typename octet_iterator>
    uint32_t peek_next(octet_iterator it, octet_iterator end)
      {
      return utf8::next(it, end);
      }

    template <typename octet_iterator>
    uint32_t prior(octet_iterator& it, octet_iterator start)
      {
      // can't do much if it == start
      if (it == start)
        throw not_enough_room();

      octet_iterator end = it;
      // Go back until we hit either a lead octet or start
      while (utf8::internal::is_trail(*(--it)))
        if (it == start)
          throw invalid_utf8(*it); // error - no lead byte in the sequence
      return utf8::peek_next(it, end);
      }

    /// Deprecated in versions that include "prior"
    template <typename octet_iterator>
    uint32_t previous(octet_iterator& it, octet_iterator pass_start)
      {
      octet_iterator end = it;
      while (utf8::internal::is_trail(*(--it)))
        if (it == pass_start)
          throw invalid_utf8(*it); // error - no lead byte in the sequence
      octet_iterator temp = it;
      return utf8::next(temp, end);
      }

    template <typename octet_iterator, typename distance_type>
    void advance(octet_iterator& it, distance_type n, octet_iterator end)
      {
      for (distance_type i = 0; i < n; ++i)
        utf8::next(it, end);
      }

    template <typename octet_iterator>
    typename std::iterator_traits<octet_iterator>::difference_type
      distance(octet_iterator first, octet_iterator last)
      {
      typename std::iterator_traits<octet_iterator>::difference_type dist;
      for (dist = 0; first < last; ++dist)
        utf8::next(first, last);
      return dist;
      }

    template <typename u16bit_iterator, typename octet_iterator>
    octet_iterator utf16to8(u16bit_iterator start, u16bit_iterator end, octet_iterator result)
      {
      while (start != end) {
        uint32_t cp = utf8::internal::mask16(*start++);
        // Take care of surrogate pairs first
        if (utf8::internal::is_lead_surrogate(cp)) {
          if (start != end) {
            uint32_t trail_surrogate = utf8::internal::mask16(*start++);
            if (utf8::internal::is_trail_surrogate(trail_surrogate))
              cp = (cp << 10) + trail_surrogate + internal::SURROGATE_OFFSET;
            else
              throw invalid_utf16(static_cast<uint16_t>(trail_surrogate));
            }
          else
            throw invalid_utf16(static_cast<uint16_t>(cp));

          }
        // Lone trail surrogate
        else if (utf8::internal::is_trail_surrogate(cp))
          throw invalid_utf16(static_cast<uint16_t>(cp));

        result = utf8::append(cp, result);
        }
      return result;
      }

    template <typename u16bit_iterator, typename octet_iterator>
    u16bit_iterator utf8to16(octet_iterator start, octet_iterator end, u16bit_iterator result)
      {
      while (start != end) {
        uint32_t cp = utf8::next(start, end);
        if (cp > 0xffff) { //make a surrogate pair
          *result++ = static_cast<uint16_t>((cp >> 10) + internal::LEAD_OFFSET);
          *result++ = static_cast<uint16_t>((cp & 0x3ff) + internal::TRAIL_SURROGATE_MIN);
          }
        else
          *result++ = static_cast<uint16_t>(cp);
        }
      return result;
      }

    template <typename octet_iterator, typename u32bit_iterator>
    octet_iterator utf32to8(u32bit_iterator start, u32bit_iterator end, octet_iterator result)
      {
      while (start != end)
        result = utf8::append(*(start++), result);

      return result;
      }

    template <typename octet_iterator, typename u32bit_iterator>
    u32bit_iterator utf8to32(octet_iterator start, octet_iterator end, u32bit_iterator result)
      {
      while (start != end)
        (*result++) = utf8::next(start, end);

      return result;
      }

    // The iterator class
    template <typename octet_iterator>
    class iterator// : public std::iterator <std::bidirectional_iterator_tag, uint32_t> 
      {
      octet_iterator it;
      octet_iterator range_start;
      octet_iterator range_end;
      public:

        typedef std::bidirectional_iterator_tag     iterator_category;
        typedef uint32_t value_type;
        typedef uint32_t* pointer;
        typedef std::ptrdiff_t difference_type;
        typedef uint32_t& reference;

        iterator() {}
        explicit iterator(const octet_iterator& octet_it,
          const octet_iterator& range_start,
          const octet_iterator& range_end) :
          it(octet_it), range_start(range_start), range_end(range_end)
          {
          if (it < range_start || it > range_end)
            throw std::out_of_range("Invalid utf-8 iterator position");
          }
        // the default "big three" are OK
        octet_iterator base() const { return it; }
        uint32_t operator * () const
          {
          octet_iterator temp = it;
          return utf8::next(temp, range_end);
          }
        bool operator == (const iterator& rhs) const
          {
          if (range_start != rhs.range_start || range_end != rhs.range_end)
            throw std::logic_error("Comparing utf-8 iterators defined with different ranges");
          return (it == rhs.it);
          }
        bool operator != (const iterator& rhs) const
          {
          return !(operator == (rhs));
          }
        iterator& operator ++ ()
          {
          utf8::next(it, range_end);
          return *this;
          }
        iterator operator ++ (int)
          {
          iterator temp = *this;
          utf8::next(it, range_end);
          return temp;
          }
        iterator& operator -- ()
          {
          utf8::prior(it, range_start);
          return *this;
          }
        iterator operator -- (int)
          {
          iterator temp = *this;
          utf8::prior(it, range_start);
          return temp;
          }
      }; // class iterator

    namespace unchecked
      {
      template <typename octet_iterator>
      octet_iterator append(uint32_t cp, octet_iterator result)
        {
        if (cp < 0x80)                        // one octet
          *(result++) = static_cast<uint8_t>(cp);
        else if (cp < 0x800) {                // two octets
          *(result++) = static_cast<uint8_t>((cp >> 6) | 0xc0);
          *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
          }
        else if (cp < 0x10000) {              // three octets
          *(result++) = static_cast<uint8_t>((cp >> 12) | 0xe0);
          *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
          *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
          }
        else {                                // four octets
          *(result++) = static_cast<uint8_t>((cp >> 18) | 0xf0);
          *(result++) = static_cast<uint8_t>(((cp >> 12) & 0x3f) | 0x80);
          *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
          *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
          }
        return result;
        }

      template <typename octet_iterator>
      uint32_t next(octet_iterator& it)
        {
        uint32_t cp = utf8::internal::mask8(*it);
        typename std::iterator_traits<octet_iterator>::difference_type length = utf8::internal::sequence_length(it);
        switch (length) {
          case 1:
            break;
          case 2:
            it++;
            cp = ((cp << 6) & 0x7ff) + ((*it) & 0x3f);
            break;
          case 3:
            ++it;
            cp = ((cp << 12) & 0xffff) + ((utf8::internal::mask8(*it) << 6) & 0xfff);
            ++it;
            cp += (*it) & 0x3f;
            break;
          case 4:
            ++it;
            cp = ((cp << 18) & 0x1fffff) + ((utf8::internal::mask8(*it) << 12) & 0x3ffff);
            ++it;
            cp += (utf8::internal::mask8(*it) << 6) & 0xfff;
            ++it;
            cp += (*it) & 0x3f;
            break;
          }
        ++it;
        return cp;
        }

      template <typename octet_iterator>
      uint32_t peek_next(octet_iterator it)
        {
        return utf8::unchecked::next(it);
        }

      template <typename octet_iterator>
      uint32_t prior(octet_iterator& it)
        {
        while (utf8::internal::is_trail(*(--it)));
        octet_iterator temp = it;
        return utf8::unchecked::next(temp);
        }

      // Deprecated in versions that include prior, but only for the sake of consistency (see utf8::previous)
      template <typename octet_iterator>
      inline uint32_t previous(octet_iterator& it)
        {
        return utf8::unchecked::prior(it);
        }

      template <typename octet_iterator, typename distance_type>
      void advance(octet_iterator& it, distance_type n)
        {
        for (distance_type i = 0; i < n; ++i)
          utf8::unchecked::next(it);
        }

      template <typename octet_iterator>
      typename std::iterator_traits<octet_iterator>::difference_type
        distance(octet_iterator first, octet_iterator last)
        {
        typename std::iterator_traits<octet_iterator>::difference_type dist;
        for (dist = 0; first < last; ++dist)
          utf8::unchecked::next(first);
        return dist;
        }

      template <typename u16bit_iterator, typename octet_iterator>
      octet_iterator utf16to8(u16bit_iterator start, u16bit_iterator end, octet_iterator result)
        {
        while (start != end) {
          uint32_t cp = utf8::internal::mask16(*start++);
          // Take care of surrogate pairs first
          if (utf8::internal::is_lead_surrogate(cp)) {
            uint32_t trail_surrogate = utf8::internal::mask16(*start++);
            cp = (cp << 10) + trail_surrogate + internal::SURROGATE_OFFSET;
            }
          result = utf8::unchecked::append(cp, result);
          }
        return result;
        }

      template <typename u16bit_iterator, typename octet_iterator>
      u16bit_iterator utf8to16(octet_iterator start, octet_iterator end, u16bit_iterator result)
        {
        while (start < end) {
          uint32_t cp = utf8::unchecked::next(start);
          if (cp > 0xffff) { //make a surrogate pair
            *result++ = static_cast<uint16_t>((cp >> 10) + internal::LEAD_OFFSET);
            *result++ = static_cast<uint16_t>((cp & 0x3ff) + internal::TRAIL_SURROGATE_MIN);
            }
          else
            *result++ = static_cast<uint16_t>(cp);
          }
        return result;
        }

      template <typename octet_iterator, typename u32bit_iterator>
      octet_iterator utf32to8(u32bit_iterator start, u32bit_iterator end, octet_iterator result)
        {
        while (start != end)
          result = utf8::unchecked::append(*(start++), result);

        return result;
        }

      template <typename octet_iterator, typename u32bit_iterator>
      u32bit_iterator utf8to32(octet_iterator start, octet_iterator end, u32bit_iterator result)
        {
        while (start < end)
          (*result++) = utf8::unchecked::next(start);

        return result;
        }

      // The iterator class
      template <typename octet_iterator>
      class iterator //: public std::iterator <std::bidirectional_iterator_tag, uint32_t> 
        {
        octet_iterator it;
        public:
          typedef std::bidirectional_iterator_tag     iterator_category;
          typedef uint32_t value_type;
          typedef uint32_t* pointer;
          typedef std::ptrdiff_t difference_type;
          typedef uint32_t& reference;

          iterator() {}
          explicit iterator(const octet_iterator& octet_it) : it(octet_it) {}
          // the default "big three" are OK
          octet_iterator base() const { return it; }
          uint32_t operator * () const
            {
            octet_iterator temp = it;
            return utf8::unchecked::next(temp);
            }
          bool operator == (const iterator& rhs) const
            {
            return (it == rhs.it);
            }
          bool operator != (const iterator& rhs) const
            {
            return !(operator == (rhs));
            }
          iterator& operator ++ ()
            {
            ::std::advance(it, utf8::internal::sequence_length(it));
            return *this;
            }
          iterator operator ++ (int)
            {
            iterator temp = *this;
            ::std::advance(it, utf8::internal::sequence_length(it));
            return temp;
            }
          iterator& operator -- ()
            {
            utf8::unchecked::prior(it);
            return *this;
            }
          iterator operator -- (int)
            {
            iterator temp = *this;
            utf8::unchecked::prior(it);
            return temp;
            }
        }; // class iterator

      } // namespace utf8::unchecked
    } // namespace utf8 
  } // namespace fu

#include <fstream>
#include <sys/stat.h>
#ifdef _WIN32
#include <algorithm>
#include <sys/types.h>
#endif

#ifdef _WIN32

/*
 * Dirent interface for Microsoft Visual Studio
 * Version 1.21
 *
 * Copyright (C) 2006-2012 Toni Ronkko
 * This file is part of dirent.  Dirent may be freely distributed
 * under the MIT license.  For all details and documentation, see
 * https://github.com/tronkko/dirent
 */

 /*
   * Define architecture flags so we don't need to include windows.h.
   * Avoiding windows.h makes it simpler to use windows sockets in conjunction
   * with dirent.h.
   */
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#   define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#include <stdio.h>
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

   /* Indicates that d_type field is available in dirent structure */
#define _DIRENT_HAVE_D_TYPE

/* Indicates that d_namlen field is available in dirent structure */
#define _DIRENT_HAVE_D_NAMLEN

/* Entries missing from MSVC 6.0 */
#if !defined(FILE_ATTRIBUTE_DEVICE)
#   define FILE_ATTRIBUTE_DEVICE 0x40
#endif

/* File type and permission flags for stat(), general mask */
#if !defined(S_IFMT)
#   define S_IFMT _S_IFMT
#endif

/* Directory bit */
#if !defined(S_IFDIR)
#   define S_IFDIR _S_IFDIR
#endif

/* Character device bit */
#if !defined(S_IFCHR)
#   define S_IFCHR _S_IFCHR
#endif

/* Pipe bit */
#if !defined(S_IFFIFO)
#   define S_IFFIFO _S_IFFIFO
#endif

/* Regular file bit */
#if !defined(S_IFREG)
#   define S_IFREG _S_IFREG
#endif

/* Read permission */
#if !defined(S_IREAD)
#   define S_IREAD _S_IREAD
#endif

/* Write permission */
#if !defined(S_IWRITE)
#   define S_IWRITE _S_IWRITE
#endif

/* Execute permission */
#if !defined(S_IEXEC)
#   define S_IEXEC _S_IEXEC
#endif

/* Pipe */
#if !defined(S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* Block device */
#if !defined(S_IFBLK)
#   define S_IFBLK 0
#endif

/* Link */
#if !defined(S_IFLNK)
#   define S_IFLNK 0
#endif

/* Socket */
#if !defined(S_IFSOCK)
#   define S_IFSOCK 0
#endif

/* Read user permission */
#if !defined(S_IRUSR)
#   define S_IRUSR S_IREAD
#endif

/* Write user permission */
#if !defined(S_IWUSR)
#   define S_IWUSR S_IWRITE
#endif

/* Execute user permission */
#if !defined(S_IXUSR)
#   define S_IXUSR 0
#endif

/* Read group permission */
#if !defined(S_IRGRP)
#   define S_IRGRP 0
#endif

/* Write group permission */
#if !defined(S_IWGRP)
#   define S_IWGRP 0
#endif

/* Execute group permission */
#if !defined(S_IXGRP)
#   define S_IXGRP 0
#endif

/* Read others permission */
#if !defined(S_IROTH)
#   define S_IROTH 0
#endif

/* Write others permission */
#if !defined(S_IWOTH)
#   define S_IWOTH 0
#endif

/* Execute others permission */
#if !defined(S_IXOTH)
#   define S_IXOTH 0
#endif

/* Maximum length of file name */
#if !defined(PATH_MAX)
#   define PATH_MAX MAX_PATH
#endif
#if !defined(FILENAME_MAX)
#   define FILENAME_MAX MAX_PATH
#endif
#if !defined(NAME_MAX)
#   define NAME_MAX FILENAME_MAX
#endif

/* File type flags for d_type */
#define DT_UNKNOWN 0
#define DT_REG S_IFREG
#define DT_DIR S_IFDIR
#define DT_FIFO S_IFIFO
#define DT_SOCK S_IFSOCK
#define DT_CHR S_IFCHR
#define DT_BLK S_IFBLK
#define DT_LNK S_IFLNK

/* Macros for converting between st_mode and d_type */
#define IFTODT(mode) ((mode) & S_IFMT)
#define DTTOIF(type) (type)

/*
 * File type macros.  Note that block devices, sockets and links cannot be
 * distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
 * only defined for compatibility.  These macros should always return false
 * on Windows.
 */
#if !defined(S_ISFIFO)
#   define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISDIR)
#   define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG)
#   define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISLNK)
#   define S_ISLNK(mode) (((mode) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK)
#   define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISCHR)
#   define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISBLK)
#   define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
#endif

 /* Return the exact length of d_namlen without zero terminator */
#define _D_EXACT_NAMLEN(p) ((p)->d_namlen)

/* Return number of bytes needed to store d_namlen */
#define _D_ALLOC_NAMLEN(p) (PATH_MAX)

namespace fu // on windows we put dirent under namespace fu to avoid nameclashes with e.g. dirent from fltk
  {

  /* Wide-character version */
  struct _wdirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    wchar_t d_name[PATH_MAX];
    };
  //typedef struct _wdirent _wdirent;

  struct _WDIR {
    /* Current directory entry */
    struct _wdirent ent;

    /* Private file data */
    WIN32_FIND_DATAW data;

    /* True if data is valid */
    int cached;

    /* Win32 search handle */
    HANDLE handle;

    /* Initial directory name */
    wchar_t* patt;
    };
  //typedef struct _WDIR _WDIR;

  static _WDIR* _wopendir(const wchar_t* dirname);
  static struct _wdirent* _wreaddir(_WDIR* dirp);
  static int _wclosedir(_WDIR* dirp);
  static void _wrewinddir(_WDIR* dirp);


  /* For compatibility with Symbian */
#define wdirent _wdirent
#define WDIR _WDIR
#define wopendir _wopendir
#define wreaddir _wreaddir
#define wclosedir _wclosedir
#define wrewinddir _wrewinddir


/* Multi-byte character versions */
  struct dirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    char d_name[PATH_MAX];
    };
  //typedef struct dirent dirent;

  struct DIR {
    struct dirent ent;
    struct _WDIR* wdirp;
    };
  typedef struct DIR DIR;

  /* Internal utility functions */
  static WIN32_FIND_DATAW* dirent_first(_WDIR* dirp);
  static WIN32_FIND_DATAW* dirent_next(_WDIR* dirp);

  static void dirent_set_errno(int error);

  /*
   * Open directory stream DIRNAME for read and return a pointer to the
   * internal working area that is used to retrieve individual directory
   * entries.
   */
  static _WDIR*
    _wopendir(
      const wchar_t* dirname)
    {
    _WDIR* dirp = NULL;
    int error;

    /* Must have directory name */
    if (dirname == NULL || dirname[0] == '\0') {
      dirent_set_errno(ENOENT);
      return NULL;
      }

    /* Allocate new _WDIR structure */
    dirp = (_WDIR*)malloc(sizeof(struct _WDIR));
    if (dirp != NULL) {
      DWORD n;

      /* Reset _WDIR structure */
      dirp->handle = INVALID_HANDLE_VALUE;
      dirp->patt = NULL;
      dirp->cached = 0;

      /* Compute the length of full path plus zero terminator */
      n = GetFullPathNameW(dirname, 0, NULL, NULL);

      /* Allocate room for absolute directory name and search pattern */
      dirp->patt = (wchar_t*)malloc(sizeof(wchar_t) * n + 16);
      if (dirp->patt) {

        /*
         * Convert relative directory name to an absolute one.  This
         * allows rewinddir() to function correctly even when current
         * working directory is changed between opendir() and rewinddir().
         */
        n = GetFullPathNameW(dirname, n, dirp->patt, NULL);
        if (n > 0) {
          wchar_t* p;

          /* Append search pattern \* to the directory name */
          p = dirp->patt + n;
          if (dirp->patt < p) {
            switch (p[-1]) {
              case '\\':
              case '/':
              case ':':
                /* Directory ends in path separator, e.g. c:\temp\ */
                /*NOP*/;
                break;

              default:
                /* Directory name doesn't end in path separator */
                *p++ = '\\';
              }
            }
          *p++ = '*';
          *p = '\0';

          /* Open directory stream and retrieve the first entry */
          if (dirent_first(dirp)) {
            /* Directory stream opened successfully */
            error = 0;
            }
          else {
            /* Cannot retrieve first entry */
            error = 1;
            dirent_set_errno(ENOENT);
            }

          }
        else {
          /* Cannot retrieve full path name */
          dirent_set_errno(ENOENT);
          error = 1;
          }

        }
      else {
        /* Cannot allocate memory for search pattern */
        error = 1;
        }

      }
    else {
      /* Cannot allocate _WDIR structure */
      error = 1;
      }

    /* Clean up in case of error */
    if (error && dirp) {
      _wclosedir(dirp);
      dirp = NULL;
      }

    return dirp;
    }

  /*
   * Read next directory entry.  The directory entry is returned in dirent
   * structure in the d_name field.  Individual directory entries returned by
   * this function include regular files, sub-directories, pseudo-directories
   * "." and ".." as well as volume labels, hidden files and system files.
   */
  static struct _wdirent*
    _wreaddir(
      _WDIR* dirp)
    {
    WIN32_FIND_DATAW* datap;
    struct _wdirent* entp;

    /* Read next directory entry */
    datap = dirent_next(dirp);
    if (datap) {
      size_t n;
      DWORD attr;

      /* Pointer to directory entry to return */
      entp = &dirp->ent;

      /*
       * Copy file name as wide-character string.  If the file name is too
       * long to fit in to the destination buffer, then truncate file name
       * to PATH_MAX characters and zero-terminate the buffer.
       */
      n = 0;
      while (n + 1 < PATH_MAX && datap->cFileName[n] != 0) {
        entp->d_name[n] = datap->cFileName[n];
        n++;
        }
      dirp->ent.d_name[n] = 0;

      /* Length of file name excluding zero terminator */
      entp->d_namlen = n;

      /* File type */
      attr = datap->dwFileAttributes;
      if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
        entp->d_type = DT_CHR;
        }
      else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        entp->d_type = DT_DIR;
        }
      else {
        entp->d_type = DT_REG;
        }

      /* Reset dummy fields */
      entp->d_ino = 0;
      entp->d_reclen = sizeof(struct _wdirent);

      }
    else {

      /* Last directory entry read */
      entp = NULL;

      }

    return entp;
    }

  /*
   * Close directory stream opened by opendir() function.  This invalidates the
   * DIR structure as well as any directory entry read previously by
   * _wreaddir().
   */
  static int
    _wclosedir(
      _WDIR* dirp)
    {
    int ok;
    if (dirp) {

      /* Release search handle */
      if (dirp->handle != INVALID_HANDLE_VALUE) {
        FindClose(dirp->handle);
        dirp->handle = INVALID_HANDLE_VALUE;
        }

      /* Release search pattern */
      if (dirp->patt) {
        free(dirp->patt);
        dirp->patt = NULL;
        }

      /* Release directory structure */
      free(dirp);
      ok = /*success*/0;

      }
    else {
      /* Invalid directory stream */
      dirent_set_errno(EBADF);
      ok = /*failure*/-1;
      }
    return ok;
    }

  /*
   * Rewind directory stream such that _wreaddir() returns the very first
   * file name again.
   */

   /*
   static void
   _wrewinddir(
       _WDIR* dirp)
   {
       if (dirp) {
           // Release existing search handle
           if (dirp->handle != INVALID_HANDLE_VALUE) {
               FindClose (dirp->handle);
           }

           // Open new search handle
           dirent_first (dirp);
       }
   }
   */

   /* Get first directory entry (internal) */
  static WIN32_FIND_DATAW*
    dirent_first(
      _WDIR* dirp)
    {
    WIN32_FIND_DATAW* datap;

    /* Open directory and retrieve the first entry */
    dirp->handle = FindFirstFileW(dirp->patt, &dirp->data);
    if (dirp->handle != INVALID_HANDLE_VALUE) {

      /* a directory entry is now waiting in memory */
      datap = &dirp->data;
      dirp->cached = 1;

      }
    else {

      /* Failed to re-open directory: no directory entry in memory */
      dirp->cached = 0;
      datap = NULL;

      }
    return datap;
    }

  /* Get next directory entry (internal) */
  static WIN32_FIND_DATAW*
    dirent_next(
      _WDIR* dirp)
    {
    WIN32_FIND_DATAW* p;

    /* Get next directory entry */
    if (dirp->cached != 0) {

      /* A valid directory entry already in memory */
      p = &dirp->data;
      dirp->cached = 0;

      }
    else if (dirp->handle != INVALID_HANDLE_VALUE) {

      /* Get the next directory entry from stream */
      if (FindNextFileW(dirp->handle, &dirp->data) != FALSE) {
        /* Got a file */
        p = &dirp->data;
        }
      else {
        /* The very last entry has been processed or an error occured */
        FindClose(dirp->handle);
        dirp->handle = INVALID_HANDLE_VALUE;
        p = NULL;
        }

      }
    else {

      /* End of directory stream reached */
      p = NULL;

      }

    return p;
    }

  /* Set errno variable */
  static void
    dirent_set_errno(
      int error)
    {
#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 and later */
    _set_errno(error);

#else

    /* Non-Microsoft compiler or older Microsoft compiler */
    errno = error;

#endif
    }

  } // namespace fu

#elif defined(unix) || defined(__unix) || defined(__unix__) || defined(UNIX) //#ifdef _WIN32
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <linux/limits.h>
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <mach-o/dyld.h>
#endif


namespace fu
  {
  FUDEF std::string get_executable_path()
    {
#ifdef _WIN32
    typedef std::vector<wchar_t> char_vector;
    typedef std::vector<wchar_t>::size_type size_type;
    char_vector buf(1024, 0);
    size_type size = buf.size();
    bool havePath = false;
    bool shouldContinue = true;
    do
      {
      DWORD result = GetModuleFileNameW(nullptr, &buf[0], (DWORD)size);
      DWORD lastError = GetLastError();
      if (result == 0)
        {
        shouldContinue = false;
        }
      else if (result < size)
        {
        havePath = true;
        shouldContinue = false;
        }
      else if (
        result == size
        && (lastError == ERROR_INSUFFICIENT_BUFFER || lastError == ERROR_SUCCESS)
        )
        {
        size *= 2;
        buf.resize(size);
        }
      else
        {
        shouldContinue = false;
        }
      } while (shouldContinue);
    if (!havePath)
      {
      return std::string("");
      }
    std::wstring wret = &buf[0];
    std::replace(wret.begin(), wret.end(), '\\', '/'); // replace all '\\' by '/'
    return convert_wstring_to_string(wret);
#elif defined(unix) || defined(__unix) || defined(__unix__) || defined(UNIX)
    char result[PATH_MAX];
    ssize_t count = readlink("/proc/self/exe", result, PATH_MAX);
    return std::string(result, (count > 0) ? count : 0);
#elif defined(__APPLE__)
    char path[1024];
    uint32_t size = sizeof(path);
    if (_NSGetExecutablePath(path, &size) == 0)
      return std::string(path);
    else
      return std::string();
#else
    return std::string();
#endif
    }

  FUDEF std::string get_cwd()
    {
#ifdef _WIN32
    wchar_t buf[MAX_PATH];
    GetCurrentDirectoryW(MAX_PATH, buf);
    std::wstring wbuf(buf);
    std::replace(wbuf.begin(), wbuf.end(), '\\', '/'); // replace all '\\' by '/'
    return fu::convert_wstring_to_string(wbuf);
#else
    char buf[PATH_MAX];
    getcwd(buf, sizeof(buf));
    return std::string(buf);
#endif
    }

  std::wstring convert_string_to_wstring(const std::string& str)
    {
    std::wstring out;
    out.reserve(str.size());
    auto it = str.begin();
    auto it_end = str.end();

    for (; it != it_end;)
      {
      uint32_t cp = 0;
      fu::utf8::internal::utf_error err_code = fu::utf8::internal::validate_next(it, it_end, cp);
      if (err_code == fu::utf8::internal::UTF8_OK)
        {
        out.push_back((wchar_t)cp);
        }
      else
        {
        out.push_back(*it);
        ++it;
        }
      }
    return out;
    }

  FUDEF std::string convert_wstring_to_string(const std::wstring& str)
    {
    std::string out;
    out.reserve(str.size());
    fu::utf8::utf16to8(str.begin(), str.end(), std::back_inserter(out));
    return out;
    }

  FUDEF bool valid_utf8_file(const std::wstring& filename)
    {
#ifdef _WIN32
    std::ifstream ifs(filename);
#else
    std::string fn = convert_wstring_to_string(filename);
    std::ifstream ifs(fn);
#endif
    if (!ifs)
      return false;

    std::istreambuf_iterator<char> it(ifs.rdbuf());
    std::istreambuf_iterator<char> eos;

    return fu::utf8::is_valid(it, eos);
    }

  FUDEF bool valid_utf8_file(const std::string& filename)
    {
#ifdef _WIN32
    std::wstring wfn = convert_string_to_wstring(filename);
    std::ifstream ifs(wfn);
#else
    std::ifstream ifs(filename);
#endif
    if (!ifs)
      return false;

    std::istreambuf_iterator<char> it(ifs.rdbuf());
    std::istreambuf_iterator<char> eos;

    return fu::utf8::is_valid(it, eos);
    }

  FUDEF bool is_directory(const std::string& directory)
    {
#ifdef _WIN32
    std::wstring wdirectory = convert_string_to_wstring(directory);
    if (wdirectory.length() >= PATH_MAX)
      return false;
    bool result = false;
    _WDIR* dir = wopendir(wdirectory.c_str());
    if (dir)
      {
      _wdirent* ent = wreaddir(dir);
      if (ent)
        result = true;
      wclosedir(dir);
      }
    return result;
#else
    if (directory.length() >= PATH_MAX)
      return false;
    bool result = false;
    DIR* dir = opendir(directory.c_str());
    if (dir)
      {
      dirent* ent = readdir(dir);
      if (ent)
        result = true;
      closedir(dir);
      }
    return result;
#endif  
    }

  FUDEF bool file_exists(const std::string& filename)
    {
#ifdef _WIN32
    std::wstring wfilename = convert_string_to_wstring(filename);
    std::ifstream f;
    f.open(wfilename, std::ifstream::in);
    if (f.fail())
      return false;
    f.close();
    return true;
#else
    if (is_directory(filename)) // This should not be necessary, but otherwise crash with gcc on Ubuntu
      return false;
    struct stat buffer;
    return (stat(filename.c_str(), &buffer) == 0);
#endif
    }

  FUDEF std::vector<std::string> get_files_from_directory(const std::string& d, bool include_subfolders)
    {
    std::string directory(d);
    if (!directory.empty() && !(directory.back() == '/' || directory.back() == '\\'))
      directory.push_back('/');
    std::vector<std::string> files;
#ifdef _WIN32
    std::wstring wdirectory = convert_string_to_wstring(directory);
    _WDIR* dir = wopendir(wdirectory.c_str());
    _wdirent* ent = nullptr;
    if (dir)
      ent = wreaddir(dir);
#else
    DIR* dir = opendir(directory.c_str());
    dirent* ent = nullptr;
    if (dir)
      ent = readdir(dir);
#endif
    if (!dir)
      return files;
    while (ent)
      {
      if (ent->d_type == DT_REG || ent->d_type == DT_LNK) // a file
        {
#ifdef _WIN32
        files.push_back(directory + convert_wstring_to_string(std::wstring(ent->d_name)));
#else
        files.push_back(directory + std::string(ent->d_name));
#endif
        }
      else if (include_subfolders && ent->d_type == DT_DIR) // a directory
        {
#ifdef _WIN32
        std::string n = convert_wstring_to_string(std::wstring(ent->d_name));
#else
        std::string n(ent->d_name);
#endif
        if (n.front() != '.')
          {
          std::string path = directory + n;
          auto files_sub = get_files_from_directory(path, include_subfolders);
          files.insert(files.end(), files_sub.begin(), files_sub.end());
          }
        }

#ifdef _WIN32
      ent = wreaddir(dir);
#else
      ent = readdir(dir);
#endif
      }
#ifdef _WIN32
    wclosedir(dir);
#else
    closedir(dir);
#endif
    return files;
    }

  FUDEF std::vector<std::string> get_subdirectories_from_directory(const std::string& d, bool include_subfolders)
    {
    std::string directory(d);
    if (!directory.empty() && !(directory.back() == '/' || directory.back() == '\\'))
      directory.push_back('/');
    std::vector<std::string> files;
#ifdef _WIN32
    std::wstring wdirectory = convert_string_to_wstring(directory);
    _WDIR* dir = wopendir(wdirectory.c_str());
    _wdirent* ent = nullptr;
    if (dir)
      ent = wreaddir(dir);
#else
    DIR* dir = opendir(directory.c_str());
    dirent* ent = nullptr;
    if (dir)
      ent = readdir(dir);
#endif
    if (!dir)
      return files;
    while (ent)
      {
      if (ent->d_type == DT_DIR) // a directory
        {
#ifdef _WIN32
        std::string n = convert_wstring_to_string(std::wstring(ent->d_name));
#else
        std::string n(ent->d_name);
#endif
        if (n.front() != '.')
          {
          files.push_back(directory + n);
          if (include_subfolders)
            {
            auto files_sub = get_subdirectories_from_directory(files.back(), include_subfolders);
            files.insert(files.end(), files_sub.begin(), files_sub.end());
            }
          }
        }

#ifdef _WIN32
      ent = wreaddir(dir);
#else
      ent = readdir(dir);
#endif
      }
#ifdef _WIN32
    wclosedir(dir);
#else
    closedir(dir);
#endif
    return files;
    }

  FUDEF std::vector<std::string> get_list_from_directory(const std::string& d, bool include_subfolders)
    {
    std::string directory(d);
    if (!directory.empty() && !(directory.back() == '/' || directory.back() == '\\'))
      directory.push_back('/');
    std::vector<std::string> files;
#ifdef _WIN32
    std::wstring wdirectory = convert_string_to_wstring(directory);
    _WDIR* dir = wopendir(wdirectory.c_str());
    _wdirent* ent = nullptr;
    if (dir)
      ent = wreaddir(dir);
#else
    DIR* dir = opendir(directory.c_str());
    dirent* ent = nullptr;
    if (dir)
      ent = readdir(dir);
#endif
    if (!dir)
      return files;
    while (ent)
      {
      if (ent->d_type == DT_REG || ent->d_type == DT_LNK) // a file
        {
#ifdef _WIN32
        files.push_back(directory + convert_wstring_to_string(std::wstring(ent->d_name)));
#else
        files.push_back(directory + std::string(ent->d_name));
#endif
        }
      else if (ent->d_type == DT_DIR) // a directory
        {
#ifdef _WIN32
        std::string n = convert_wstring_to_string(std::wstring(ent->d_name));
#else
        std::string n(ent->d_name);
#endif

        if (n.front() != '.')
          {
          files.push_back(directory + n);
          if (include_subfolders)
            {
            auto files_sub = get_list_from_directory(files.back(), include_subfolders);
            files.insert(files.end(), files_sub.begin(), files_sub.end());
            }
          }
        }

#ifdef _WIN32
      ent = wreaddir(dir);
#else
      ent = readdir(dir);
#endif
      }
#ifdef _WIN32
    wclosedir(dir);
#else
    closedir(dir);
#endif
    return files;
    }

  FUDEF std::string get_extension(const std::string& filename)
    {
    std::wstring wfilename = convert_string_to_wstring(filename);
    auto ext_ind = wfilename.find_last_of('.');
    std::wstring ext;
    if (ext_ind != std::wstring::npos)
      ext = wfilename.substr(ext_ind + 1);
    return convert_wstring_to_string(ext);
    }

  FUDEF std::string remove_extension(const std::string& filename)
    {
    std::wstring wfilename = convert_string_to_wstring(filename);
    auto ext_ind = wfilename.find_last_of('.');
    if (ext_ind == std::wstring::npos)
      return filename;
    return convert_wstring_to_string(wfilename.substr(0, ext_ind));
    }

  FUDEF std::string get_folder(const std::string& path)
    {
    std::wstring wpath = convert_string_to_wstring(path);
    auto pos1 = wpath.find_last_of('/');
    auto pos2 = wpath.find_last_of('\\');
    if (pos1 == std::wstring::npos && pos2 == std::wstring::npos)
      return "";
    if (pos1 == std::wstring::npos)
      return convert_wstring_to_string(wpath.substr(0, pos2 + 1));
    if (pos2 == std::wstring::npos)
      return convert_wstring_to_string(wpath.substr(0, pos1 + 1));
    return convert_wstring_to_string(wpath.substr(0, (pos1 > pos2 ? pos1 : pos2) + 1));
    }

  FUDEF std::string get_filename(const std::string& path)
    {
    std::wstring wpath = convert_string_to_wstring(path);
    auto pos1 = wpath.find_last_of('/');
    auto pos2 = wpath.find_last_of('\\');
    if (pos1 == std::wstring::npos && pos2 == std::wstring::npos)
      return path;
    if (pos1 == std::wstring::npos)
      return convert_wstring_to_string(wpath.substr(pos2 + 1));
    if (pos2 == std::wstring::npos)
      return convert_wstring_to_string(wpath.substr(pos1 + 1));
    return convert_wstring_to_string(wpath.substr((pos1 > pos2 ? pos1 : pos2) + 1));
    }

  FUDEF std::string getenv(const std::string& name)
    {
#ifdef _WIN32
    std::wstring ws = fu::convert_string_to_wstring(name);
    wchar_t* path = _wgetenv(ws.c_str());
    if (!path)
      return nullptr;
    std::wstring wresult(path);
    std::string out = fu::convert_wstring_to_string(wresult);
#else
    std::string out(::getenv(name.c_str()));
#endif
    return out;
    }

  FUDEF void putenv(const std::string& name, const std::string& value)
    {
#ifdef _WIN32
    std::wstring wvalue = fu::convert_string_to_wstring(value);
    std::wstring wname = fu::convert_string_to_wstring(name);
    _wputenv_s(wname.c_str(), wvalue.c_str());
#else
    ::setenv(name.c_str(), value.c_str(), 1);
#endif
    }

  namespace details
    {
    FUDEF std::string remove_nl_cr(const std::string& str)
      {
      std::string cleaned(str);
      while (!cleaned.empty() && (cleaned.back() == '\n' || cleaned.back() == '\r'))
        cleaned.pop_back();
      return cleaned;
      }

    FUDEF std::string add_brackets_iff_separator(const std::string& str, const char* separator = ",")
      {
      std::wstring w = convert_string_to_wstring(str);
      std::wstring sep = convert_string_to_wstring(std::string(separator));
      if (w.find_first_of(sep) != std::wstring::npos)
        {
        w.insert(0, 1, '"');
        w.push_back('"');
        }
      return convert_wstring_to_string(w);
      }

    FUDEF const wchar_t* wstrchr(const wchar_t* s, wchar_t c)
      {
      while (*s != c)
        if (!*s++)
          return 0;
      return (const wchar_t*)s;
      }

    FUDEF size_t wstrcspn(const wchar_t* s1, const wchar_t* s2)
      {
      size_t ret = 0;
      while (*s1)
        if (wstrchr(s2, *s1))
          return ret;
        else
          s1++, ret++;
      return ret;
      }

    FUDEF const wchar_t* wstrpbrk(const wchar_t* s1, const wchar_t* s2)
      {
      while (*s1)
        if (wstrchr(s2, *s1++))
          return (const wchar_t*)--s1;
      return nullptr;
      }

    FUDEF const wchar_t* wstrpbrk_brackets(const wchar_t* str1, const wchar_t* str2)
      {
      const wchar_t* targ = wstrpbrk(str1, str2);
      if (!targ)
        return nullptr;
      const wchar_t* brackets1 = wstrpbrk(str1, L"\"");
      if (brackets1)
        {
        if (brackets1 < targ)
          {
          const wchar_t* brackets2 = wstrpbrk(brackets1 + 1, L"\"");
          if (!brackets2)
            return nullptr;
          return wstrpbrk_brackets(brackets2 + 1, str2);
          }
        else
          return targ;
        }
      else
        return targ;
      }

    FUDEF std::string remove_brackets(const std::string& str)
      {
      if (str.empty())
        return str;
      if (str.front() == '"' && str.back() == '"')
        {
        return std::string(str.begin() + 1, str.end() - 1);
        }
      return str;
      }
    }

  FUDEF void csv_write(const std::vector<std::vector<std::string>>& data, FILE* stream, const char* separator)
    {
    using namespace details;
    for (const auto& line : data)
      {
      for (size_t i = 0; i < line.size() - 1; ++i)
        {
        std::string w = add_brackets_iff_separator(line[i], separator);
        fprintf(stream, "%s%s", w.c_str(), separator);
        }
      std::string w = add_brackets_iff_separator(line.back());
      fprintf(stream, "%s\n", w.c_str());
      }
    }

  FUDEF bool csv_write(const std::vector<std::vector<std::string>>& data, const char* filename, const char* separator)
    {
    FILE* f = fopen(filename, "w");
    if (f == nullptr)
      return false;
    csv_write(data, f, separator);
    fclose(f);
    return true;
    }

  FUDEF void csv_read(std::vector<std::vector<std::string>>& data, FILE* stream, const char* separator)
    {
    using namespace details;
    char line[16384];
    std::wstring wsep = convert_string_to_wstring(separator);
    while (fgets(line, 16383, stream))
      {
      std::wstring wline = convert_string_to_wstring(std::string(line));
      std::vector<std::string> dataline;
      const wchar_t* first = wline.c_str();
      const wchar_t* last = wstrpbrk_brackets(wline.c_str(), wsep.c_str());
      if (last != nullptr)
        dataline.push_back(remove_brackets(remove_nl_cr(convert_wstring_to_string(std::wstring(first, last)))));
      else
        dataline.push_back(remove_brackets(remove_nl_cr(convert_wstring_to_string(std::wstring(first)))));
      while (last != nullptr)
        {
        first = last + 1;
        last = wstrpbrk_brackets(last + 1, wsep.c_str());
        if (last != nullptr)
          dataline.push_back(remove_brackets(remove_nl_cr(convert_wstring_to_string(std::wstring(first, last)))));
        else
          dataline.push_back(remove_brackets(remove_nl_cr(convert_wstring_to_string(std::wstring(first)))));
        }
      data.push_back(dataline);
      }
    }

  FUDEF bool csv_read(std::vector<std::vector<std::string>>& data, const char* filename, const char* separator)
    {
    FILE* f = fopen(filename, "r");
    if (f == nullptr)
      return false;
    csv_read(data, f, separator);
    fclose(f);
    return true;
    }

#ifdef _WIN32
  FUDEF long long file_size(const std::string& filename)
    {
    struct _stat64 st;

    std::wstring wfilename = convert_string_to_wstring(filename);

    if (_wstat64(wfilename.c_str(), &st) == 0)
      return st.st_size;

    return -1;
    }
#else
  FUDEF long long file_size(const std::string& filename)
    {
    struct stat st;

    if (stat(filename.c_str(), &st) == 0)
      return st.st_size;

    return -1;
    }
#endif

  } // namespace fu


#endif //FILE_UTILS_IMPLEMENTATION
